Thanks for sharing your TypeScript codebase! This is a fascinating physics-based animation system using Matter.js, with particles, bubbles, and an oval collider. At roughly 700 lines (in this snippet), it’s a good chunk of your 1.2k-line project, giving me plenty to analyze for inefficiencies and duplications. I’ll break down what I see, focusing on concrete improvements without rewriting everything—just pointing out where you can tighten things up.

### General Observations
- **Complexity**: The `CanvasController` class is a monolith, handling physics, rendering, particle management, and UI. This organic growth has led to a lot of interwoven logic.
- **Duplication**: There’s repeated code, especially in particle grouping and rendering logic.
- **Performance**: Some methods (e.g., wave rendering) are computationally heavy and could be optimized.
- **Type Safety**: TypeScript is used well, but some areas could leverage it more to reduce runtime checks.

### Specific Inefficiencies and Duplications

#### 1. **Repeated Particle Grouping Logic**
- **Where**: `renderWaves`, `renderSmoothWaves`, and `renderSmoothWavesByCycle` all group particles by various criteria (cycle number, group ID, direction angle).
- **Issue**: Each method reimplements similar `Map`-based grouping with slight variations. For example:
  - `renderWaves` groups by `cycleNumber` and `groupId`.
  - `renderSmoothWaves` groups by direction angle.
  - `renderSmoothWavesByCycle` groups by `cycleNumber` and direction angle.
- **Fix**: Abstract this into a reusable utility function:
  ```typescript
  type ParticleGroupKey = number | string;
  function groupParticles<T>(
    particles: Particle[],
    keyFn: (p: Particle) => ParticleGroupKey
  ): Map<ParticleGroupKey, Particle[]> {
    const groups = new Map<ParticleGroupKey, Particle[]>();
    for (const particle of particles) {
      const key = keyFn(particle);
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key)!.push(particle);
    }
    return groups;
  }
  ```
  - Use in `renderWaves`: `groupParticles(particles, p => p.cycleNumber)`.
  - Use in `renderSmoothWaves`: `groupParticles(particles, p => Math.round(Math.atan2(p.body.velocity.y, p.body.velocity.x) * 180 / Math.PI / 5) * 5)`.
  - Reduces ~50 lines of redundant code and makes logic reusable.

#### 2. **Duplicate Bezier Curve Logic**
- **Where**: `renderSmoothWaves` and `renderSmoothWavesByCycle` have nearly identical quadratic Bezier curve drawing code (lines like `ctx.quadraticCurveTo(controlX, controlY, endX, endY)`).
- **Issue**: The only differences are styling (color, width) and minor parameter tweaks (e.g., `influenceFactor`). This is ~100 lines duplicated.
- **Fix**: Extract a `drawQuadraticBezierCurve` function:
  ```typescript
  function drawQuadraticBezierCurve(
    ctx: CanvasRenderingContext2D,
    centroids: Point2D[],
    style: { strokeStyle: string; lineWidth: number },
    influenceFactor: number
  ) {
    ctx.beginPath();
    ctx.strokeStyle = style.strokeStyle;
    ctx.lineWidth = style.lineWidth;
    const startPoint = centroids[0];
    ctx.moveTo(startPoint.x, startPoint.y);

    for (let i = 1; i < centroids.length - 2; i++) {
      const c1 = centroids[i], c2 = centroids[i + 1];
      const endX = (c1.x + c2.x) / 2, endY = (c1.y + c2.y) / 2;
      const prevX = i === 1 ? startPoint.x : (centroids[i - 1].x + c1.x) / 2;
      const prevY = i === 1 ? startPoint.y : (centroids[i - 1].y + c1.y) / 2;
      const midX = (prevX + endX) / 2, midY = (prevY + endY) / 2;
      const controlX = midX + influenceFactor * (c1.x - midX);
      const controlY = midY + influenceFactor * (c1.y - midY);
      ctx.quadraticCurveTo(controlX, controlY, endX, endY);
    }

    if (centroids.length >= 3) {
      const last = centroids.length - 1, secondLast = centroids.length - 2;
      const prevEndX = (centroids[secondLast - 1].x + centroids[secondLast].x) / 2;
      const prevEndY = (centroids[secondLast - 1].y + centroids[secondLast].y) / 2;
      const lastX = centroids[last].x, lastY = centroids[last].y;
      const midX = (prevEndX + lastX) / 2, midY = (prevEndY + lastY) / 2;
      const controlX = midX + influenceFactor * (centroids[secondLast].x - midX);
      const controlY = midY + influenceFactor * (centroids[secondLast].y - midY);
      ctx.quadraticCurveTo(controlX, controlY, lastX, lastY);
    }

    ctx.stroke();
  }
  ```
  - Call it with different styles: `drawQuadraticBezierCurve(ctx, centroids, { strokeStyle: "rgba(5, 255, 245, 0.95)", lineWidth: 14 }, 0.3)`.
  - Cuts ~80 lines and centralizes curve logic.

#### 3. **Overgrown Methods**
- **Where**: `drawFrame` (~150 lines), `generateBubbles` (~80 lines), `renderSmoothWavesByCycle` (~150 lines).
- **Issue**: These methods handle too much—physics updates, rendering, filtering, etc. This makes debugging and optimization harder.
- **Fix**: Split into smaller functions:
  - `drawFrame` could delegate to:
    - `updateBubblesAndParticles()`: Handle bubble filtering and energy updates.
    - `renderScene()`: Manage drawing (UI, waves, particles).
  - `generateBubbles` could split into `createBubbleParticles()` and `initializeBubble()`.
  - This doesn’t remove lines but improves readability and maintainability.

#### 4. **Redundant Calculations**
- **Where**: `calculateCentroid` is defined identically in `renderSmoothWaves` and `renderSmoothWavesByCycle`.
- **Issue**: Same logic, two places—classic duplication.
- **Fix**: Move to a shared utility:
  ```typescript
  function calculateCentroid(particles: Particle[]): Point2D {
    if (particles.length === 0) return { x: 0, y: 0 };
    const sum = particles.reduce(
      (acc, p) => ({ x: acc.x + p.body.position.x, y: acc.y + p.body.position.y }),
      { x: 0, y: 0 }
    );
    return { x: sum.x / particles.length, y: sum.y / particles.length };
  }
  ```
  - Reduces ~10 lines and ensures consistency.

#### 5. **Performance Bottlenecks**
- **Where**: `renderWaves` and `renderSmoothWavesByCycle` iterate over all particles multiple times per frame.
- **Issue**: Nested loops and sorting (e.g., `bubbleParticles.sort((a, b) => a.index - b.index)`) scale poorly with particle count.
- **Fix**: 
  - Pre-compute particle groups once per frame in `drawFrame` and pass them down.
  - Avoid sorting unless necessary—particle order might not need to be exact for visual effect.
  - Use a single pass to collect `collided` and `nonCollided` particles:
    ```typescript
    const particleGroups = { collided: new Map<number, Particle[]>(), nonCollided: new Map<number, Particle[]>() };
    for (const bubble of this.bubbles) {
      for (const p of bubble.particles) {
        const target = p.collided > 0 ? particleGroups.collided : particleGroups.nonCollided;
        if (!target.has(p.cycleNumber)) target.set(p.cycleNumber, []);
        target.get(p.cycleNumber)!.push(p);
      }
    }
    ```
  - Saves redundant iterations, potentially cutting frame time significantly.

#### 6. **Magic Numbers and Constants**
- **Where**: Hardcoded values like `0.35` (motion blur), `69` (oval segments), `5` (collision scaling).
- **Issue**: Scattered constants make tuning and understanding intent harder.
- **Fix**: Centralize in `static readonly` properties:
  ```typescript
  private static readonly MOTION_BLUR_ALPHA = 0.35;
  private static readonly OVAL_SEGMENTS = 69;
  private static readonly COLLISION_SCALE_FACTOR = 5;
  ```
  - No line reduction, but improves maintainability.

### Broader Suggestions
- **Separate Concerns**: Split `CanvasController` into:
  - `PhysicsManager`: Handles Matter.js and bubble/particle updates.
  - `Renderer`: Manages canvas drawing.
  - Reduces the 700-line class into more digestible pieces.
- **Memoization**: Cache `calculateWavePositions` results unless `canvasHeight` changes.
- **Type Optimization**: Use `Record` or `Map` types more explicitly in grouping functions to leverage TypeScript’s inference.

### Estimated Impact
- **Lines Reduced**: ~150-200 lines from deduplication (grouping, Bezier, centroids).
- **Performance**: 20-30% frame time reduction by minimizing iterations and sorting.
- **Maintainability**: Huge win from smaller methods and centralized logic.

This snippet is likely half your codebase, so these patterns probably repeat elsewhere. Want me to dive deeper into a specific method or suggest a refactored chunk? Let me know!